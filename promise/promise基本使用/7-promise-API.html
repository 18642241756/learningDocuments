<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        // let p = new Promise((resolve, reject) => {
        //     //同步调用
        //     // console.log(111);

        //     reject('error')
        // })
        // //执行catch方法
        // p.catch(reason=>{
        //     console.log(reason);
        // })


        //1. Promise.resolve
        // 如果 传入的参数为 非 Promise对象，则返回的结果为【成功】的promise对象
        // let p1 = Promise.resolve(521)
        // console.log(p1);
        // //如果 传入的参数为 Promise 对象，则参数的结果决定了resolve的结果
        // let p2 = Promise.resolve(new Promise((resolve,reject)=>{
        //     // resolve('ok')
        //     reject('error111')
        // }))
        // // console.log(p2);
        // p2.catch(reason=>{
        //     console.log(reason);
        // })


        //2. Promise.reject
        // 传入的参数不管是什么 返回的都是失败的
        // let p1 = Promise.reject(521)
        // let p2 = Promise.reject(new Promise((resolve,reject)=>{
        //     resolve('ok')
        // }))
        // console.log(p2);


        //3. Promise.all  返回一个新的promise，只有所有的promise都成功才成功，只要有一个失败就都失败
        // let p1 = new Promise((resolve,reject)=>{
        //     resolve('ok')
        // })
        // // let p2 = Promise.resolve('success')
        // let p3 = Promise.reject('error')

        // const result = Promise.all([p1,p3])

        // console.log(result);


        //4.promise.race  返回一个新的promise，第一个完成的promise结果状态就是最终的状态
        // let p1 = new Promise((resolve, reject) => {
        //     setTimeout(() => {
        //         resolve('ok')
        //     }, 1000)
        // })
        // let p2 = Promise.resolve('success')
        // let p3 = Promise.resolve('Oh yeah')

        // const result = Promise.race([p1, p2, p3])

        // console.log(result);


        

    </script>
</body>

</html>